# 鉴权    

## session-cookie  
### cookie  
&emsp;&emsp;HTTP协议是一个无状态的协议，服务器不会知道到底是哪一台浏览器访问了它，因此需要一个标识来让服务器区分不同的浏览器。cookie就是这个管理服务器与客户端之间状态的标识。  
&emsp;&emsp;cookie的原理是，浏览器第一次向服务器发送请求时，服务器在response头部设置 Set-Cookie 字段，浏览器收到响应就会设置cookie并储存，在下一次浏览器向服务器发送请求时，就会在request头部自动带上Cookie字段，服务器端收到该cookie用以区分不同的浏览器。当然，这个cookie与某个用户的对应关系应该在第一次访问时就存在服务器端，这时就需要session了。  

### session  
&emsp;&emsp;session是会话的意思，浏览器第一次访问服务器，服务器就会创建一次会话，在会话中保存标识该浏览器的信息。它与cookie的区别就是session是缓存在服务器端的，cookie则是缓存在客户端，它们都由服务端生成，为了弥补Http协议无状态的缺陷。  

### session-cookie认证  

* 服务器在接受客户端首次访问时创建session，然后保存session（可以保存在内存或redis中，推荐使用redis），然后给这个session生成一个唯一的标识字符串，并在响应头中设置这个唯一标识字符串。
* 签名。通过密钥对sid进行签名处理，避免客户端修改sid。
* 浏览器收到响应的时候会解析响应头，然后将sid保存在本地cookie中。在下次http请求的请求头中会带上该域名下的cookie信息。
* 服务器在接受客户端请求时会去解析请求头cookie中的sid，然后根据这个sid从缓存（或者redis）中查找该客户端的session，判断是否合法。

## Token验证（JWT）  
&emsp;&emsp;token是一个令牌，浏览器第一次访问服务端时会签发一张令牌，之后浏览器每次携带这张令牌访问服务端就会认证该令牌是否有效，只要服务端可以解密该令牌，就说明请求是合法的。  
&emsp;&emsp;令牌中包含的用户信息还可以区分不同身份的用户。一般token由用户信息、时间戳和签名（由hash算法加密）构成。  

### Token认证流程  

* 客户端使用用户名和密码请求登录
* 服务器收到请求，去验证用户名和密码
* 验证成功后，服务端会签发一个 Token ，再把这个Token发送给客户端
* 客户端收到Token后将其储存起来，放入cookie或者localStorage中
* 客户端每次向服务端请求资源的时候需要携带Token
* 服务端收到请求，然后去验证客户端请求中携带的Token（request头部添加 Authorization）。如果验证成功，就向客户端返回请求的数据；失败则返回401错误码（鉴权失败）

### Token和session的区别  

* session-cookie的缺点：
    * 认证方式局限在浏览器中使用，cookie是浏览器的机制，如果在app端就无法使用cookie。
    * 为了满足全局一致性，我们最好把session存储在redis中做持久化，而在分布式环境下，我们可能需要在每个服务器上都备份，占用了大量的存储空间。
    * 在不是Https协议下使用cookie，容易受到CSRF跨站请求伪造攻击。
* token的缺点：  
    * 加密解密消耗使得token认证比session-cookie更消耗性能。
    * token比sessionId大，更占带宽。
* 两者对比：  
    * token认证不局限于浏览器，这样就使得这种认证方式可以支持多种客户端，而不仅是浏览器。且不受同源策略的影响。
    * 不使用cookie就可以规避CSRF攻击。
    * token不需要存储，token中已经包含了用户信息。服务器端变成无状态，只需要根据定义的规则校验这个token是否合法就行了。这也使得token的可扩展性更强。

### JWT（JSON Web Token）  
&emsp;&emsp;JWT的原理：服务器认证以后，生成一个JSON对象，这个JSON对象肯定不能裸传给用户，不然谁都可以篡改这个对象发送请求。因此这个JSON对象会被服务器端签名加密后返回给用户，返回的内容就是一个令牌，以后用户每次访问服务器端都得带着这个令牌。  
&emsp;&emsp;这个JSON对象可能包含的内容就是：用户信息，用户身份以及令牌的过期时间。

#### JWT的组成  
&emsp;&emsp;JWT由三部分组成：Header（头部）、Payload（负载）、Signature（签名）。

* Header部分是一个JSON对象，描述JWT的元数据。一般描述信息为该Token的加密算法以及Token的类型。`{"alg": "HS256", "typ": "JWT"}`的意思就是，该token使用 HS256 加密，类型是JWT。这个部分基本相当于明文，它将这个JSON对象做了一个Base64转码，变成一个字符串。Base64编码解码的算法是可逆的。头部信息默认携带这两个字段。
* Payload部分也是一个JSON对象，用来存放实际需要传递的数据。有7个官方字段，还可以在这个部分定义私有字段。一般存放用户名、用户身份以及一些JWT的描述字段。它也只是做了一个Base64编码，因此肯定不能在其中存放秘密信息，比如登录密码之类的。
* Signature是对前面两个部分的签名，防止数据篡改，如果前面两段信息被人修改了发送给服务器端，此时服务器端是可以利用签名来验证信息的正确性的。签名需要密钥，密钥是服务器端保存的，用户不知道。算出签名以后，把Header、Payload、Signature三个部分拼成一个字符串，每个部分之间用“点”（.）分隔，就可以返回给用户。

#### JWT的特点  

* JWT默认是不加密的，但也是可以加密的。生成原始Token以后，可以用密钥再加密一次。
* JWT在不加密的情况下，不能将秘密数据写入JWT。
* JWT不仅可以用于认证，也可以用于交换信息。有效使用JWT，可以降低服务器查询数据库的次数。
* JWT的最大缺点是，由于服务器不保存session状态，因此无法在使用过程中废止某个token，或者更改token的权限。也就是说，一旦JWT签发了，在到期之前就会始终有限，除非服务器部署额外的逻辑。
* JWT本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些重要的权限，使用时应该再次对用户进行认证。
* 为了减少盗用，JWT不应该使用HTTP协议明码传输，要使用HTTPS协议传输

## OAuth  

&emsp;&emsp;三方登入主要基于OAuth2.0 。OAuth协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是OAuth的授权不会使第三方触及到用户的账号信息（如用户名和密码），即第三方无需使用用户名和密码就可以申请获得该用户资源的授权，因此OAuth是安全的。我们常见的提供OAuth认证服务的厂商有支付宝、QQ、微信。这样的授权方式使得用户使用门槛低，可以更好的推广自己的应用。

### OAuth认证流程  
&emsp;&emsp;OAuth就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进行系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。  
&emsp;&emsp;OAuth有四种获取令牌的方式，不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码“客户端ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。  
&emsp;&emsp;在前后端分离的情景下，我们常使用授权码方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。